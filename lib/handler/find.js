// Generated by CoffeeScript 1.7.1
(function() {
  var Boom, ref2resource, resource_uri, _;

  _ = require('lodash');

  Boom = require('boom');

  resource_uri = require('./helpers').resource_uri;

  ref2resource = require('./helpers').ref2resource;

  module.exports = function(Model, path, options) {
    return function(req, res) {
      var limit, query, skip, sort, where;
      limit = req.query.limit || options.page_size;
      skip = req.query.skip || void 0;
      sort = req.query.sort || void 0;
      limit = parseInt(limit);
      if (skip != null) {
        skip = parseInt(skip);
      }
      query = _.merge(req.query, req.params);
      where = _.transform(query, function(conditions, value, key) {
        var val;
        if (key !== 'limit' && key !== 'skip' && key !== 'sort') {
          val = JSON.parse(value);
          if (_.isObject(val)) {
            return conditions[key] = val;
          } else {
            return conditions[key] = value;
          }
        }
      });
      return Model.find(where).sort(sort).skip(skip).limit(limit).exec(function(err, models) {
        var count, model, output, _i, _len;
        if (err) {
          return res(Boom.badImplementation(err.message));
        }
        for (_i = 0, _len = models.length; _i < _len; _i++) {
          model = models[_i];
          resource_uri(model, path, options.resource_key);
          ref2resource(model, options.refs);
        }
        output = {};
        output.meta = {};
        output.meta.page_size = limit;
        count = 0;
        return Model.count(where, function(err, count) {
          var new_skip, next, prev;
          if (err) {
            return res(Boom.badImplementation(err.message));
          }
          output.meta.total_count = count;
          if (count > limit && count > skip + limit) {
            if (skip != null) {
              new_skip = skip + limit;
            } else {
              new_skip = limit;
            }
            next = path + "?";
            if (sort) {
              next += "sort=" + sort + "&";
            }
            next += "skip=" + new_skip + "&limit=" + limit;
          } else {
            next = null;
          }
          output.meta.next = next;
          if ((skip != null) && skip !== 0) {
            if ((skip - limit) < 0) {
              new_skip = 0;
            } else {
              new_skip = skip - limit;
            }
            prev = path + "?";
            if (sort) {
              prev += "sort=" + sort + "&";
            }
            prev += "skip=" + new_skip + "&limit=" + limit;
          } else {
            prev = null;
          }
          output.meta.previous = prev;
          output.objects = models;
          return res(output);
        });
      });
    };
  };

}).call(this);
